import { Type } from "@flect/core";
// Functions for ensuring raw dependencies become full dependencies
function buildDependency(dep) {
    if (dep instanceof Type) {
        const type = dep;
        const strict = false;
        const key = null;
        return { type, strict, key };
    }
    return dep;
}
function buildDependencies(deps) {
    return deps.map(buildDependency); // todo: wish this could be a less aggresssive cast, or none at all somehow
}
export class DependencyResolutionError extends Error {
    bound;
    key;
    constructor(bound, key) {
        super(`Could not resolve dependency: ${JSON.stringify({ bound, key })}`);
        this.bound = bound;
        this.key = key;
        Object.setPrototypeOf(this, DependencyResolutionError.prototype);
    }
}
// Storage for providers
class ProviderStorage {
    constructor() {
        this._map = new Map();
    }
    store(bound, provider) {
        let keyMap = this._map.get(bound);
        if (keyMap === undefined) {
            keyMap = new Map();
            this._map.set(bound, keyMap);
        }
        keyMap.set(provider.key, provider);
    }
    retrieve(bound, key) {
        const keyMap = this._map.get(bound);
        if (keyMap === undefined) {
            throw new DependencyResolutionError(bound, key);
        }
        const result = keyMap.get(key);
        if (result === undefined) {
            throw new DependencyResolutionError(bound, key);
        }
        return result;
    }
    _map;
}
class InstanceStorage {
    constructor() {
        this._map = new Map();
    }
    store(bound, key, instance) {
        let keyMap = this._map.get(bound);
        if (keyMap === undefined) {
            keyMap = new Map();
            this._map.set(bound, keyMap);
        }
        keyMap.set(key, instance);
    }
    retrieve(bound, key) {
        const keyMap = this._map.get(bound);
        if (keyMap === undefined) {
            return null;
        }
        const result = keyMap.get(key);
        console.log({ bound, key, result });
        if (result === undefined) {
            return null;
        }
        return result;
    }
    _map;
}
// Fluent builder for implementation provision
// Should these be reduced to underlying types, with wrapping done in params?
class Binder {
    constructor(storage, bound, dependencies, key) {
        this._storage = storage;
        this._bound = bound;
        this._dependencies = dependencies;
        this._key = key;
    }
    with(...moreDeps) {
        return new Binder(this._storage, this._bound, [...this._dependencies, ...buildDependencies(moreDeps)], this._key);
    }
    toFactory(impl) {
        ;
        this._storage.store(this._bound, { dependencies: this._dependencies, impl, key: this._key });
    }
    toType(implementor) {
        const impl = (...args) => new implementor(...args);
        this._storage.store(this._bound, { dependencies: this._dependencies, impl, key: this._key });
    }
    toInstance(instance) {
        return this.toFactory(() => instance);
    }
    _storage;
    _bound;
    _dependencies;
    _key;
}
;
// IoC container. Bind stuff in, resolve stuff out.
export class Container {
    constructor() {
        this._storage = new ProviderStorage();
        this._instanceStorage = new InstanceStorage();
    }
    // Bind to a type, with optional key. Use keys
    // if you have multiple implementations of a type
    bind(bound, key = null) {
        return new Binder(this._storage, bound, [], key);
    }
    // Resolve a type with optional key. Will resolve
    // any dependencies of the implementation as well.
    // Use keys if you have multiple implementatiosn of a type
    resolve(boundInterface, key = null) {
        let result = this._instanceStorage.retrieve(boundInterface, key);
        if (result === null) {
            const { dependencies, impl } = this._storage.retrieve(boundInterface, key);
            let newResult = Reflect.apply(impl, null, dependencies.map((d) => this.resolveDependency(d))); // TODO -- tuple map
            this._instanceStorage.store(boundInterface, key, newResult);
            return newResult;
        }
        return result;
    }
    resolveDependency(dep) {
        if (dep.key !== null) {
            try {
                return this.resolve(dep.type, dep.key);
            }
            catch (ex) {
                if (!dep.strict) {
                    return this.resolve(dep.type);
                }
                else {
                    throw ex;
                }
            }
        }
        return this.resolve(dep.type);
    }
    _storage;
    _instanceStorage;
}
// Function to get a full dependency instead
// of just a type.
export function dep(type, key = null, strict = true) {
    return { type, key, strict };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGFBQWEsQ0FBQztBQWVuQyxtRUFBbUU7QUFDbkUsU0FBUyxlQUFlLENBQW9CLEdBQXFCO0lBQ2hFLElBQUksR0FBRyxZQUFZLElBQUksRUFBRTtRQUN4QixNQUFNLElBQUksR0FBRyxHQUFHLENBQUM7UUFDakIsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQztRQUNqQixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQztLQUM3QjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ1osQ0FBQztBQUNELFNBQVMsaUJBQWlCLENBQW9DLElBQXdCO0lBQ3JGLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQVEsQ0FBQyxDQUFDLDJFQUEyRTtBQUNySCxDQUFDO0FBcUJELE1BQU0sT0FBTyx5QkFBMEIsU0FBUSxLQUFLO0lBQ2hDO0lBQTBCO0lBQTdDLFlBQW1CLEtBQWlCLEVBQVMsR0FBWTtRQUN4RCxLQUFLLENBQUMsaUNBQWlDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFEdkQsVUFBSyxHQUFMLEtBQUssQ0FBWTtRQUFTLFFBQUcsR0FBSCxHQUFHLENBQVM7UUFFeEQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUseUJBQXlCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEUsQ0FBQztDQUNEO0FBRUQsd0JBQXdCO0FBQ3hCLE1BQU0sZUFBZTtJQUNwQjtRQUNDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRU0sS0FBSyxDQUFDLEtBQWlCLEVBQUUsUUFB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LENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM5QjtxQkFBTTtvQkFDTixNQUFNLEVBQUUsQ0FBQztpQkFDVDthQUNEO1NBQ0Q7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFTyxRQUFRLENBQWtCO0lBQzFCLGdCQUFnQixDQUFrQjtDQUMxQztBQUVELDRDQUE0QztBQUM1QyxrQkFBa0I7QUFDbEIsTUFBTSxVQUFVLEdBQUcsQ0FDbEIsSUFBYSxFQUNiLE1BQWUsSUFBSSxFQUNuQixTQUFrQixJQUFJO0lBRXRCLE9BQU8sRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBQyxDQUFDO0FBQzVCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlIH0gZnJvbSBcIkBmbGVjdC9jb3JlXCI7XHJcblxyXG4vLyBXaGF0IGNhbiBiZSBpbmplY3RlZC9yZXNvc2x2ZWRcclxudHlwZSBJbmplY3RhYmxlID0gVHlwZTtcclxuXHJcbi8vIFBvc3NpYmxlIGtleXMgZm9yIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIG11bHRpcGxlIGltcGxlbWVudGF0aW9uc1xyXG4vLyBEZWZhdWx0IGlzIG51bGxcclxudHlwZSBLZXlUeXBlID0gc3ltYm9sIHwgbnVsbDtcclxuXHJcbi8vIEZ1bGwgZGVwZW5kZW5jaWVzLCBpbmNsdWRpbmcga2V5cyBhbmQgc3RyaWN0bmVzc1xyXG50eXBlIERlcGVuZGVuY3k8VD4gPSB7IHR5cGU6IFR5cGU8VD4sIHN0cmljdDogYm9vbGVhbiwga2V5OiBLZXlUeXBlIH1cclxudHlwZSBEZXBlbmRlbmNpZXM8VCBleHRlbmRzIHJlYWRvbmx5IFsuLi51bmtub3duW11dPiA9IHtbSyBpbiBrZXlvZiBUXTogRGVwZW5kZW5jeTxUW0tdPn1cclxudHlwZSBSYXdEZXBlbmRlbmN5PFQ+ID0gRGVwZW5kZW5jeTxUPnxUeXBlPFQ+O1xyXG50eXBlIFJhd0RlcGVuZGVuY2llczxUIGV4dGVuZHMgcmVhZG9ubHkgWy4uLnVua25vd25bXV0+ID0ge1tLIGluIGtleW9mIFRdOiBSYXdEZXBlbmRlbmN5PFRbS10+fVxyXG5cclxuLy8gRnVuY3Rpb25zIGZvciBlbnN1cmluZyByYXcgZGVwZW5kZW5jaWVzIGJlY29tZSBmdWxsIGRlcGVuZGVuY2llc1xyXG5mdW5jdGlvbiBidWlsZERlcGVuZGVuY3k8VCBleHRlbmRzIHVua25vd24+KGRlcDogUmF3RGVwZW5kZW5jeTxUPik6IERlcGVuZGVuY3k8VD4ge1xyXG5cdGlmIChkZXAgaW5zdGFuY2VvZiBUeXBlKSB7XHJcblx0XHRjb25zdCB0eXBlID0gZGVwO1xyXG5cdFx0Y29uc3Qgc3RyaWN0ID0gZmFsc2U7XHJcblx0XHRjb25zdCBrZXkgPSBudWxsO1xyXG5cdFx0cmV0dXJuIHsgdHlwZSwgc3RyaWN0LCBrZXkgfTtcclxuXHR9XHJcblx0cmV0dXJuIGRlcDtcclxufVxyXG5mdW5jdGlvbiBidWlsZERlcGVuZGVuY2llczxUIGV4dGVuZHMgcmVhZG9ubHkgWy4uLnVua25vd25bXV0+KGRlcHM6IFJhd0RlcGVuZGVuY2llczxUPik6IERlcGVuZGVuY2llczxUPiB7XHJcblx0cmV0dXJuIGRlcHMubWFwKGJ1aWxkRGVwZW5kZW5jeSkgYXMgYW55OyAvLyB0b2RvOiB3aXNoIHRoaXMgY291bGQgYmUgYSBsZXNzIGFnZ3Jlc3NzaXZlIGNhc3QsIG9yIG5vbmUgYXQgYWxsIHNvbWVob3dcclxufVxyXG5cclxuLy8gVGhlIHR5cGUgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb24gbmVlZGVkIHRvIHJlZ2lzdGVyIGEgcHJvdmlkZXJcclxudHlwZSBGYWN0b3J5PFREZXBzIGV4dGVuZHMgcmVhZG9ubHkgWy4uLnVua25vd25bXV0sIFRJbnRlcmZhY2UgZXh0ZW5kcyB1bmtub3duPiA9ICguLi5hcmdzOiBURGVwcykgPT4gVEludGVyZmFjZTtcclxuXHJcbi8vIEhvdyBhbiBpbmplY3RhYmxlIGlzIHJlc29sdmVkXHJcbnR5cGUgUHJvdmlkZXIgPSB7XHJcblx0Ly8gRGVwZW5kZW5jaWVzIG5lZWRlZCB0byByZXNvbHZlIHRoaXMgaW5qZWN0YWJsZVxyXG5cdGRlcGVuZGVuY2llczogRGVwZW5kZW5jaWVzPHJlYWRvbmx5IFsuLi51bmtub3duW11dPixcclxuXHQvLyBJbXBsZW1lbnRhdGlvbiB0byBjYWxsIHRvIGdldCBpbmplY3RhYmxlLlxyXG5cdC8vIERlcGVuZGVuY2llcyBhcmUgcHJvdmlkZWQgYXMgcGFyYW1ldGVyc1xyXG5cdC8vIE5vdGUgdGhhdCB0eXBlcyBhcmUgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIHRoZWlyIGNvbnN0cnVjdG9yXHJcblx0Ly8gSXQgd291bGQgYmUgdmVyeSBuaWNlIGlmIHRoaXMgY291bGQgYmUgRmFjdG9yeTxEZXBlbmRlbmNpZXMsIEluamVjdGFibGU+IGluc3RlYWRcclxuXHRpbXBsOiBGYWN0b3J5PGFueSwgYW55PixcclxuXHQvLyBPcHRpb25hbCBrZXkgaWYgbXVsdGlwbGUgaW1wbGVtZW50YXRpb25zIGFyZSBkZXNpcmVkXHJcblx0a2V5OiBzeW1ib2wgfCBudWxsO1xyXG59O1xyXG5cclxuLy8gQSB0eXBlIHRoYXQgaW1wbGVtZW50cyBhbiBpbnRlcmZhY2UuIE9uY2UgYm91bmQgd2lsbCBiZSB3cmFwcGVkIGluIGFuIGFwcHJvcHJpYXRlIGZhY3RvcnlcclxudHlwZSBJbXBsZW1lbnRvcjxUSW50ZXJmYWNlIGV4dGVuZHMgdW5rbm93biwgVERlcHMgZXh0ZW5kcyByZWFkb25seSBbLi4udW5rbm93bltdXT4gPSB7IG5ldyguLi5hcmdzOiBURGVwcyk6IFRJbnRlcmZhY2UgfTtcclxuXHJcbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5UmVzb2x1dGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBib3VuZDogSW5qZWN0YWJsZSwgcHVibGljIGtleTogS2V5VHlwZSkge1xyXG5cdFx0c3VwZXIoYENvdWxkIG5vdCByZXNvbHZlIGRlcGVuZGVuY3k6ICR7SlNPTi5zdHJpbmdpZnkoeyBib3VuZCwga2V5IH0pfWApO1xyXG5cdFx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIERlcGVuZGVuY3lSZXNvbHV0aW9uRXJyb3IucHJvdG90eXBlKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIFN0b3JhZ2UgZm9yIHByb3ZpZGVyc1xyXG5jbGFzcyBQcm92aWRlclN0b3JhZ2Uge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0b3JlKGJvdW5kOiBJbmplY3RhYmxlLCBwcm92aWRlcjogUHJvdmlkZXIpIHtcclxuXHRcdGxldCBrZXlNYXAgPSB0aGlzLl9tYXAuZ2V0KGJvdW5kKTtcclxuXHRcdGlmIChrZXlNYXAgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRrZXlNYXAgPSBuZXcgTWFwKCk7XHJcblx0XHRcdHRoaXMuX21hcC5zZXQoYm91bmQsIGtleU1hcCk7XHJcblx0XHR9XHJcblx0XHRrZXlNYXAuc2V0KHByb3ZpZGVyLmtleSwgcHJvdmlkZXIpO1xyXG5cdH1cclxuXHRwdWJsaWMgcmV0cmlldmUoYm91bmQ6IEluamVjdGFibGUsIGtleTogS2V5VHlwZSkge1xyXG5cdFx0Y29uc3Qga2V5TWFwID0gdGhpcy5fbWFwLmdldChib3VuZCk7XHJcblx0XHRpZiAoa2V5TWFwID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IERlcGVuZGVuY3lSZXNvbHV0aW9uRXJyb3IoYm91bmQsIGtleSk7XHJcblx0XHR9XHJcblx0XHRjb25zdCByZXN1bHQgPSBrZXlNYXAuZ2V0KGtleSk7XHJcblx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IERlcGVuZGVuY3lSZXNvbHV0aW9uRXJyb3IoYm91bmQsIGtleSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHRwcml2YXRlIF9tYXA6IE1hcDxcclxuXHRcdEluamVjdGFibGUsIC8vIFdoYXQgd2UncmUgZ29pbmcgdG8gZ2V0XHJcblx0XHRNYXA8S2V5VHlwZSwgUHJvdmlkZXI+XHJcblx0PjtcdFxyXG59XHJcblxyXG5jbGFzcyBJbnN0YW5jZVN0b3JhZ2Uge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHN0b3JlKGJvdW5kOiBJbmplY3RhYmxlLCBrZXk6IEtleVR5cGUsIGluc3RhbmNlOiB1bmtub3duKSB7XHJcblx0XHRsZXQga2V5TWFwID0gdGhpcy5fbWFwLmdldChib3VuZCk7XHJcblx0XHRpZiAoa2V5TWFwID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0a2V5TWFwID0gbmV3IE1hcCgpO1xyXG5cdFx0XHR0aGlzLl9tYXAuc2V0KGJvdW5kLCBrZXlNYXApO1xyXG5cdFx0fVxyXG5cdFx0a2V5TWFwLnNldChrZXksIGluc3RhbmNlKTtcclxuXHR9XHJcblx0cHVibGljIHJldHJpZXZlPFQ+KGJvdW5kOiBJbmplY3RhYmxlLCBrZXk6IEtleVR5cGUpIHtcclxuXHRcdGNvbnN0IGtleU1hcCA9IHRoaXMuX21hcC5nZXQoYm91bmQpO1xyXG5cdFx0aWYgKGtleU1hcCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgcmVzdWx0ID0ga2V5TWFwLmdldChrZXkpO1xyXG5cdFx0Y29uc29sZS5sb2coe2JvdW5kLCBrZXksIHJlc3VsdH0pO1xyXG5cdFx0aWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdCBhcyBUO1xyXG5cdH1cclxuXHRwcml2YXRlIF9tYXA6IE1hcDxcclxuXHRcdEluamVjdGFibGUsIC8vIFdoYXQgd2UncmUgZ29pbmcgdG8gZ2V0XHJcblx0XHRNYXA8S2V5VHlwZSwgdW5rbm93bj5cclxuXHQ+O1xyXG59XHJcblxyXG4vLyBGbHVlbnQgYnVpbGRlciBmb3IgaW1wbGVtZW50YXRpb24gcHJvdmlzaW9uXHJcbi8vIFNob3VsZCB0aGVzZSBiZSByZWR1Y2VkIHRvIHVuZGVybHlpbmcgdHlwZXMsIHdpdGggd3JhcHBpbmcgZG9uZSBpbiBwYXJhbXM/XHJcbmNsYXNzIEJpbmRlcjxUSW50ZXJmYWNlIGV4dGVuZHMgdW5rbm93biwgVERlcFR5cGVzIGV4dGVuZHMgcmVhZG9ubHkgWy4uLnVua25vd25bXV0+IHtcclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdHN0b3JhZ2U6IFByb3ZpZGVyU3RvcmFnZSxcclxuXHRcdGJvdW5kOiBUeXBlPFRJbnRlcmZhY2U+LFxyXG5cdFx0ZGVwZW5kZW5jaWVzOiBEZXBlbmRlbmNpZXM8VERlcFR5cGVzPixcclxuXHRcdGtleTogS2V5VHlwZVxyXG5cdCkge1xyXG5cdFx0dGhpcy5fc3RvcmFnZSA9IHN0b3JhZ2U7XHJcblx0XHR0aGlzLl9ib3VuZCA9IGJvdW5kO1xyXG5cdFx0dGhpcy5fZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xyXG5cdFx0dGhpcy5fa2V5ID0ga2V5O1xyXG5cdH1cclxuXHJcblx0cHVibGljIHdpdGg8VE1vcmVEZXBzIGV4dGVuZHMgcmVhZG9ubHkgWy4uLnVua25vd25bXV0+KC4uLm1vcmVEZXBzOiBSYXdEZXBlbmRlbmNpZXM8VE1vcmVEZXBzPikge1xyXG5cdFx0cmV0dXJuIG5ldyBCaW5kZXIoXHJcblx0XHRcdHRoaXMuX3N0b3JhZ2UsXHJcblx0XHRcdHRoaXMuX2JvdW5kLFxyXG5cdFx0XHRbLi4udGhpcy5fZGVwZW5kZW5jaWVzLCAuLi5idWlsZERlcGVuZGVuY2llcyhtb3JlRGVwcyldIGFzIGNvbnN0LFxyXG5cdFx0XHR0aGlzLl9rZXlcclxuXHRcdCk7IFxyXG5cdH1cclxuXHJcblx0cHVibGljIHRvRmFjdG9yeShpbXBsOiBGYWN0b3J5PFREZXBUeXBlcywgVEludGVyZmFjZT4pIHs7XHJcblx0XHR0aGlzLl9zdG9yYWdlLnN0b3JlKHRoaXMuX2JvdW5kLCB7IGRlcGVuZGVuY2llczogdGhpcy5fZGVwZW5kZW5jaWVzLCBpbXBsLCBrZXk6IHRoaXMuX2tleX0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvVHlwZShpbXBsZW1lbnRvcjogSW1wbGVtZW50b3I8VEludGVyZmFjZSwgVERlcFR5cGVzPikge1xyXG5cdFx0Y29uc3QgaW1wbDogKC4uLmFyZ3M6IFREZXBUeXBlcykgPT4gVEludGVyZmFjZSA9ICguLi5hcmdzKSA9PiBuZXcgaW1wbGVtZW50b3IoLi4uYXJncyk7XHJcblx0XHR0aGlzLl9zdG9yYWdlLnN0b3JlKHRoaXMuX2JvdW5kLCB7IGRlcGVuZGVuY2llczogdGhpcy5fZGVwZW5kZW5jaWVzLCBpbXBsLCBrZXk6IHRoaXMuX2tleX0pO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHRvSW5zdGFuY2UoaW5zdGFuY2U6IFRJbnRlcmZhY2UpIHtcclxuXHRcdHJldHVybiB0aGlzLnRvRmFjdG9yeSgoKSA9PiBpbnN0YW5jZSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIF9zdG9yYWdlOiBQcm92aWRlclN0b3JhZ2U7XHJcblx0cHJpdmF0ZSBfYm91bmQ6IFR5cGU8VEludGVyZmFjZT47XHJcblx0cHJpdmF0ZSBfZGVwZW5kZW5jaWVzOiBEZXBlbmRlbmNpZXM8VERlcFR5cGVzPjtcclxuXHRwcml2YXRlIF9rZXk6IEtleVR5cGU7XHJcbn07XHJcblxyXG4vLyBJb0MgY29udGFpbmVyLiBCaW5kIHN0dWZmIGluLCByZXNvbHZlIHN0dWZmIG91dC5cclxuZXhwb3J0IGNsYXNzIENvbnRhaW5lciB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHR0aGlzLl9zdG9yYWdlID0gbmV3IFByb3ZpZGVyU3RvcmFnZSgpO1xyXG5cdFx0dGhpcy5faW5zdGFuY2VTdG9yYWdlID0gbmV3IEluc3RhbmNlU3RvcmFnZSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gQmluZCB0byBhIHR5cGUsIHdpdGggb3B0aW9uYWwga2V5LiBVc2Uga2V5c1xyXG5cdC8vIGlmIHlvdSBoYXZlIG11bHRpcGxlIGltcGxlbWVudGF0aW9ucyBvZiBhIHR5cGVcclxuXHRwdWJsaWMgYmluZDxUSW50ZXJmYWNlIGV4dGVuZHMgdW5rbm93bj4oYm91bmQ6IFR5cGU8VEludGVyZmFjZT4sIGtleTogS2V5VHlwZSA9IG51bGwpIHtcclxuXHRcdHJldHVybiBuZXcgQmluZGVyKHRoaXMuX3N0b3JhZ2UsIGJvdW5kLCBbXSwga2V5KTtcclxuXHR9XHJcblxyXG5cdC8vIFJlc29sdmUgYSB0eXBlIHdpdGggb3B0aW9uYWwga2V5LiBXaWxsIHJlc29sdmVcclxuXHQvLyBhbnkgZGVwZW5kZW5jaWVzIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBhcyB3ZWxsLlxyXG5cdC8vIFVzZSBrZXlzIGlmIHlvdSBoYXZlIG11bHRpcGxlIGltcGxlbWVudGF0aW9zbiBvZiBhIHR5cGVcclxuXHRwdWJsaWMgcmVzb2x2ZTxUSW50ZXJmYWNlIGV4dGVuZHMgdW5rbm93bj4oYm91bmRJbnRlcmZhY2U6IFR5cGU8VEludGVyZmFjZT4sIGtleTogS2V5VHlwZSA9IG51bGwpOiBUSW50ZXJmYWNlIHtcclxuXHRcdGxldCByZXN1bHQgPSB0aGlzLl9pbnN0YW5jZVN0b3JhZ2UucmV0cmlldmU8VEludGVyZmFjZT4oYm91bmRJbnRlcmZhY2UsIGtleSk7XHJcblx0XHRpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcblx0XHRcdGNvbnN0IHsgZGVwZW5kZW5jaWVzLCBpbXBsIH0gPSB0aGlzLl9zdG9yYWdlLnJldHJpZXZlKGJvdW5kSW50ZXJmYWNlLCBrZXkpO1xyXG5cdFx0XHRsZXQgbmV3UmVzdWx0ID0gUmVmbGVjdC5hcHBseTxudWxsLCBJbmplY3RhYmxlW10sIFRJbnRlcmZhY2U+KGltcGwsIG51bGwsIGRlcGVuZGVuY2llcy5tYXAoKGQpID0+IHRoaXMucmVzb2x2ZURlcGVuZGVuY3koZCkpIGFzIGFueSk7IC8vIFRPRE8gLS0gdHVwbGUgbWFwXHJcblx0XHRcdHRoaXMuX2luc3RhbmNlU3RvcmFnZS5zdG9yZShib3VuZEludGVyZmFjZSwga2V5LCBuZXdSZXN1bHQpO1xyXG5cdFx0XHRyZXR1cm4gbmV3UmVzdWx0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVzb2x2ZURlcGVuZGVuY3k8VEludGVyZmFjZSBleHRlbmRzIHVua25vd24+KGRlcDogRGVwZW5kZW5jeTxUSW50ZXJmYWNlPikge1xyXG5cdFx0aWYgKGRlcC5rZXkgIT09IG51bGwpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZXNvbHZlKGRlcC50eXBlLCBkZXAua2V5KTtcclxuXHRcdFx0fSBjYXRjaCAoZXgpIHtcclxuXHRcdFx0XHRpZiAoIWRlcC5zdHJpY3QpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnJlc29sdmUoZGVwLnR5cGUpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBleDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnJlc29sdmUoZGVwLnR5cGUpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBfc3RvcmFnZTogUHJvdmlkZXJTdG9yYWdlO1xyXG5cdHByaXZhdGUgX2luc3RhbmNlU3RvcmFnZTogSW5zdGFuY2VTdG9yYWdlO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBnZXQgYSBmdWxsIGRlcGVuZGVuY3kgaW5zdGVhZFxyXG4vLyBvZiBqdXN0IGEgdHlwZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlcDxUPihcclxuXHR0eXBlOiBUeXBlPFQ+LFxyXG5cdGtleTogS2V5VHlwZSA9IG51bGwsXHJcblx0c3RyaWN0OiBib29sZWFuID0gdHJ1ZVxyXG4pOiBEZXBlbmRlbmN5PFQ+IHtcclxuXHRyZXR1cm4ge3R5cGUsIGtleSwgc3RyaWN0fTtcclxufSJdfQ==